import pygame
import random
import sys
from dataclasses import dataclass

pygame.init()
pygame.mixer.init()

# -------------------------
# 기본 설정
# -------------------------
GAME_W, GAME_H = 480, 800       # 논리적인 게임 화면 크기 (세로형)
window = pygame.display.set_mode((GAME_W, GAME_H), pygame.RESIZABLE)
pygame.display.set_caption("에녹이 키우기")

# 실제 게임을 그릴 오프스크린 Surface (480x800 고정)
screen = pygame.Surface((GAME_W, GAME_H))

clock = pygame.time.Clock()
FPS = 60

# -------------------------
# ★ 한글 폰트 파일 지정
# -------------------------
KOREAN_FONT_FILE = "NanumGothic.otf"  # 같은 폴더에 두기

# -------------------------
# ★ 미니게임 아이콘 기본 크기
# -------------------------
MINI_BTN_BASE_SIZE = 130  # 아이콘 기본 사이즈 (폭에 맞춰 자동 조절)

# -------------------------
# ★ 메인 게임용 이미지 파일 이름
# -------------------------
START_BG_FILE = "background.png"
TUTORIAL_BG_FILE = "tutorial_bg.jpg"
GAME_BG_FILE = "background_start.jpg"   # 스토리/게임 기본 배경
TUTORIAL_IMG_FILE = "tutorial_text.png"

# 스토리에서 쓸 에녹이 사진들 (페이지별로 다르게)
STORY_PHOTO_FILES = [
    "story1.png",   # STORY_1
    "story2.png",   # STORY_2
    "story3.png",   # STORY_3
]

# 본게임에서 쓸 에녹이 사진
GAME_PHOTO_FILE = "my_photo.png"

# 자는 에녹이 사진
SLEEP_PHOTO_FILE = "sleep.png"

# 본게임 배경(아침/점심/저녁)
MORNING_BG_FILE = "bg_morning.jpg"
NOON_BG_FILE    = "bg_noon.jpg"
EVENING_BG_FILE = "bg_evening.jpg"

# 미니게임 아이콘 (왼쪽부터 체력, 지능, 외모, 포만)
MINI_ICON_FILES = [
    "mini_health.png",   # 체력
    "mini_intel.png",    # 지능
    "mini_look.png",     # 외모
    "mini_full.png",     # 포만
]

# -------------------------
# ★ 외모 미니게임(카드 짝맞추기) 설정
# -------------------------
CARDGAME_ROWS, CARDGAME_COLS = 4, 5
CARDGAME_CARD_PADDING = 10
CARDGAME_TOP_MARGIN = 120
CARDGAME_BG_COLOR = (30, 30, 30)
CARDGAME_CARD_COLOR = (200, 200, 200)
CARDGAME_BACK_COLOR = (50, 120, 200)
CARDGAME_BORDER_COLOR = (0, 0, 0)
CARDGAME_REVEAL_DELAY_MS = 700
CARDGAME_MAX_ATTEMPTS = 25
CARDGAME_ASPECT_RATIO = 1.3  # height / width
CARDGAME_IMAGE_PATTERN = "card{}.jpg"
CARDGAME_NUM_PAIRS = (CARDGAME_ROWS * CARDGAME_COLS) // 2
CARDGAME_IMAGE_ROTATIONS = [0, 0, 0, -90, -90, 0, 0, 0, 0, 0]

cardgame_images = None   # 카드 이미지 캐시

# -------------------------
# 지능 퀴즈 미니게임용 퀴즈 데이터
# -------------------------
quizzes = [
    ("컴퓨팅 사고란 무엇인가?",
     ["컴퓨터 과학 개념을 활용해 문제를 해결하는 사고방식",
      "컴퓨터를 이해하는 사고방식"], 0),

    ("컴퓨팅 사고의 핵심 요소가 아닌 것은?",
     ["알고리즘", "디버깅"], 1),

    ("문제를 작은 단위로 나누어 해결하는 과정은?",
     ["분해", "분석"], 0),

    ("문제 해결 과정에서 패턴을 찾는 활동은?",
     ["패턴 인식", "패턴 추측"], 0),

    ("알고리즘이란 무엇인가?",
     ["문제 해결 절차", "문제 만들기 방법"], 0),

    ("불필요한 정보를 제거하는 과정은?",
     ["추상화(Abstraction)", "확대(Zoom In)"], 0),

    ("효율적인 해결 방안을 만드는 과정은?",
     ["알고리즘 설계", "외워서 해결하기"], 0),

    ("컴퓨팅 사고의 예로 올바른 것은?",
     ["요리 레시피를 단계별로 정리", "요리된 음식 먹기"], 0),

    ("파이썬 반복문은?",
     ["for문", "to문"], 0),

    ("프로그램 흐름 제어 요소는?",
     ["조건문(if)", "색깔 선택 기능"], 0),

    ("알고리즘의 특징으로 맞는 것은?",
     ["명확한 단계로 구성", "순서 상관없이 작성해도 됨"], 0),

    ("자동화(Automation)의 의미는?",
     ["반복 작업을 컴퓨터가 대신 수행하도록 함", "모든 일을 사람이 직접 수행"], 0),

    ("디버깅(Debugging)이란?",
     ["오류를 찾고 수정하는 과정", "컴퓨터 장비 교체"], 0),

    ("좋은 알고리즘의 조건이 아닌 것은?",
     ["명확해야 함", "결과가 매번 달라야 함"], 1),

    ("모듈화(Modularity)란?",
     ["큰 시스템을 작은 부분으로 나누는 것", "코드를 한 곳에 몰아쓰기"], 0)
]

# -------------------------
# 폰트 설정
# -------------------------
def load_font(size):
    try:
        return pygame.font.Font(KOREAN_FONT_FILE, size)
    except Exception as e:
        print(f"[경고] 폰트 로드 실패: {KOREAN_FONT_FILE} -> {e}")
        return pygame.font.Font(None, size)

FONT = load_font(60)
TUTORIAL_FONT = load_font(40)
STORY_FONT = load_font(26)
NEXT_FONT = load_font(28)
MINI_FONT = load_font(24)
STAT_FONT = load_font(28)
DAY_FONT = load_font(22)

# -------------------------
# 이미지 로드 유틸
# -------------------------
def load_and_scale(path, size):
    try:
        img = pygame.image.load(path).convert_alpha()
        return pygame.transform.smoothscale(img, size)
    except Exception as e:
        print(f"[경고] 이미지 로드 실패: {path} -> {e}")
        surf = pygame.Surface(size, pygame.SRCALPHA)
        surf.fill((0, 0, 0, 0))
        return surf

def load_keep_aspect(path, target_size):
    tw, th = target_size
    try:
        img = pygame.image.load(path).convert_alpha()
        w, h = img.get_size()
        scale = min(tw / w, th / h)
        nw, nh = int(w * scale), int(h * scale)
        return pygame.transform.smoothscale(img, (nw, nh))
    except Exception as e:
        print(f"[경고] 이미지 로드 실패: {path} -> {e}")
        surf = pygame.Surface(target_size, pygame.SRCALPHA)
        surf.fill((0, 0, 0, 0))
        return surf

# -------------------------
# 전역 이미지 Surface
# -------------------------
background_start = None
background_tutorial = None
background_game_default = None
background_morning = None
background_noon = None
background_evening = None

tutorial_img = None
story_photo_imgs = [None, None, None]
game_photo_img = None
sleeping_img = None
mini_icon_imgs = []

# -------------------------
# 카드 클래스 (외모 미니게임)
# -------------------------
@dataclass
class Card:
    value: int
    rect: pygame.Rect
    revealed: bool = False
    matched: bool = False

# -------------------------
# 외모 미니게임: 카드 이미지 로드
# -------------------------
def load_cardgame_images():
    global cardgame_images
    if cardgame_images is not None:
        return cardgame_images

    if len(CARDGAME_IMAGE_ROTATIONS) != CARDGAME_NUM_PAIRS:
        print(f"[에러] CARDGAME_IMAGE_ROTATIONS 길이({len(CARDGAME_IMAGE_ROTATIONS)})가 "
              f"쌍 개수({CARDGAME_NUM_PAIRS})와 다릅니다.")
        pygame.quit()
        sys.exit()

    imgs = []
    for i in range(CARDGAME_NUM_PAIRS):
        filename = CARDGAME_IMAGE_PATTERN.format(i)
        try:
            img = pygame.image.load(filename).convert_alpha()
        except FileNotFoundError:
            print(f"[에러] 카드 이미지 파일을 찾을 수 없습니다: {filename}")
            pygame.quit()
            sys.exit()
        angle = CARDGAME_IMAGE_ROTATIONS[i]
        if angle % 360 != 0:
            img = pygame.transform.rotate(img, angle)
        imgs.append(img)

    cardgame_images = imgs
    return cardgame_images

# -------------------------
# 외모 미니게임: 카드 생성
# -------------------------
def create_cardgame_cards(rows, cols, area_rect):
    total = rows * cols
    assert total % 2 == 0, "카드 수는 짝수여야 합니다."

    values = list(range(total // 2)) * 2
    random.shuffle(values)

    cards = []

    total_vertical_padding = (rows + 1) * CARDGAME_CARD_PADDING
    available_height = area_rect.height - total_vertical_padding
    card_h = available_height // rows

    card_w = int(card_h / CARDGAME_ASPECT_RATIO)

    total_width_needed = cols * card_w + (cols + 1) * CARDGAME_CARD_PADDING
    start_x = area_rect.x + (area_rect.width - total_width_needed) // 2
    start_y = area_rect.y

    i = 0
    for r in range(rows):
        for c in range(cols):
            x = start_x + CARDGAME_CARD_PADDING + c * (card_w + CARDGAME_CARD_PADDING)
            y = start_y + CARDGAME_CARD_PADDING + r * (card_h + CARDGAME_CARD_PADDING)
            rect = pygame.Rect(x, y, card_w, card_h)
            cards.append(Card(value=values[i], rect=rect))
            i += 1
    return cards

# -------------------------
# 외모 미니게임: 카드 그리기
# -------------------------
def draw_cardgame_cards(cards, surface):
    imgs = load_cardgame_images()
    for card in cards:
        if card.revealed or card.matched:
            pygame.draw.rect(surface, CARDGAME_CARD_COLOR, card.rect)
            img = imgs[card.value]
            img_w, img_h = img.get_size()
            scale = min(card.rect.width / img_w, card.rect.height / img_h)
            new_w = int(img_w * scale)
            new_h = int(img_h * scale)
            img_scaled = pygame.transform.smoothscale(img, (new_w, new_h))
            x = card.rect.x + (card.rect.width - new_w) // 2
            y = card.rect.y + (card.rect.height - new_h) // 2
            surface.blit(img_scaled, (x, y))
        else:
            pygame.draw.rect(surface, CARDGAME_BACK_COLOR, card.rect)

        pygame.draw.rect(surface, CARDGAME_BORDER_COLOR, card.rect, 2)

# -------------------------
# 외모 미니게임: 클릭 카드 찾기
# -------------------------
def find_cardgame_card_at(cards, pos):
    for card in cards:
        if card.rect.collidepoint(pos) and not card.matched:
            return card
    return None

# -------------------------
# 외모 미니게임 실행
#  - 끝나면 "success"/"fail"/None 반환
# -------------------------
def play_appearance_minigame():
    global window
    load_cardgame_images()

    prev_window_size = window.get_size()
    prev_caption = pygame.display.get_caption()

    info = pygame.display.Info()
    full_w, full_h = info.current_w, info.current_h
    window = pygame.display.set_mode((full_w, full_h))  # 크게 사용

    area = pygame.Rect(
        20,
        CARDGAME_TOP_MARGIN,
        full_w - 40,
        full_h - CARDGAME_TOP_MARGIN - 20
    )
    cards = create_cardgame_cards(CARDGAME_ROWS, CARDGAME_COLS, area)

    first_card = None
    second_card = None
    last_reveal_time = 0
    attempts = 0
    matches = 0
    game_over = False
    game_result = None

    card_font = load_font(48)
    small_font = load_font(28)

    mini_running = True
    while mini_running:
        dt = clock.tick(FPS)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    mini_running = False
                    game_result = None

            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if game_over:
                    mini_running = False
                else:
                    if attempts >= CARDGAME_MAX_ATTEMPTS:
                        continue
                    if first_card and second_card:
                        pass
                    else:
                        clicked = find_cardgame_card_at(cards, event.pos)
                        if clicked and not clicked.revealed:
                            clicked.revealed = True
                            if not first_card:
                                first_card = clicked
                            else:
                                second_card = clicked
                                attempts += 1
                                last_reveal_time = pygame.time.get_ticks()

        # 매치 판정
        if (not game_over and
            first_card and second_card and
            not first_card.matched and not second_card.matched):
            now = pygame.time.get_ticks()
            if now - last_reveal_time >= CARDGAME_REVEAL_DELAY_MS:
                if first_card.value == second_card.value:
                    first_card.matched = True
                    second_card.matched = True
                    matches += 1
                else:
                    first_card.revealed = False
                    second_card.revealed = False

                first_card = None
                second_card = None
                last_reveal_time = 0

        # 성공/실패 판정
        if not game_over:
            if matches == CARDGAME_NUM_PAIRS and attempts <= CARDGAME_MAX_ATTEMPTS:
                game_over = True
                game_result = "success"
            elif attempts == CARDGAME_MAX_ATTEMPTS and matches < CARDGAME_NUM_PAIRS:
                game_over = True
                game_result = "fail"
                for card in cards:
                    card.revealed = True

        # 화면 그리기
        window.fill(CARDGAME_BG_COLOR)

        info_text = f"시도: {attempts}/{CARDGAME_MAX_ATTEMPTS}    매치: {matches}/{CARDGAME_NUM_PAIRS}"
        info_surf = small_font.render(info_text, True, (220, 220, 220))
        window.blit(info_surf, (20, 20))

        draw_cardgame_cards(cards, window)

        if game_over and game_result is not None:
            if game_result == "success":
                msg = "성공!"
                color = (255, 230, 100)
            else:
                msg = "실패!"
                color = (255, 100, 100)

            result_txt = card_font.render(msg, True, color)
            result_rect = result_txt.get_rect(center=(full_w // 2, full_h // 2))
            window.blit(result_txt, result_rect)

            tip = small_font.render("화면을 클릭하면 본게임으로 돌아갑니다", True, (230, 230, 230))
            tip_rect = tip.get_rect(center=(full_w // 2, full_h // 2 + 60))
            window.blit(tip, tip_rect)

        pygame.display.flip()

    # 본게임 윈도우 복원
    window = pygame.display.set_mode(prev_window_size, pygame.RESIZABLE)
    pygame.display.set_caption(prev_caption[0])

    reload_assets_for_size(GAME_W, GAME_H)
    update_button_positions(GAME_W, GAME_H)

    return game_result

# -------------------------
# 지능 퀴즈 미니게임 실행
#  - 끝나면 "success"/"fail"/None 반환
# -------------------------
def play_intelligence_quiz_minigame():
    global window

    prev_window_size = window.get_size()
    prev_caption = pygame.display.get_caption()

    info = pygame.display.Info()
    full_w, full_h = info.current_w, info.current_h
    window = pygame.display.set_mode((full_w, full_h))  # 크게 사용

    # 색 & 폰트
    BG_COLOR = (30, 30, 30)
    WHITE = (255, 255, 255)
    title_font = load_font(42)
    quiz_font = load_font(32)
    small_font = load_font(26)

    # 문제 하나 랜덤 선택
    question, options, answer = random.choice(quizzes)

    # 보기 박스
    BOX_SIZE = 40
    box1_rect = pygame.Rect(50, int(full_h * 0.45), BOX_SIZE, BOX_SIZE)
    box2_rect = pygame.Rect(50, int(full_h * 0.55), BOX_SIZE, BOX_SIZE)

    running = True    # 루프용
    result = None     # None: 진행 중, True: 정답, False: 오답

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    running = False
                    result = None

                elif result is None:
                    if event.key == pygame.K_1:
                        result = (0 == answer)
                    elif event.key == pygame.K_2:
                        result = (1 == answer)
                else:
                    # 결과 후 아무 키나 -> 종료
                    running = False

            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if result is None:
                    if box1_rect.collidepoint(event.pos):
                        result = (0 == answer)
                    elif box2_rect.collidepoint(event.pos):
                        result = (1 == answer)
                else:
                    # 결과 후 클릭 -> 종료
                    running = False

        # 화면 그리기
        window.fill(BG_COLOR)

        # 제목
        title_surf = title_font.render("컴퓨팅 사고 퀴즈", True, WHITE)
        title_rect = title_surf.get_rect(center=(full_w // 2, int(full_h * 0.15)))
        window.blit(title_surf, title_rect)

        # 문제
        question_surf = quiz_font.render(question, True, WHITE)
        q_rect = question_surf.get_rect(midleft=(50, int(full_h * 0.3)))
        window.blit(question_surf, q_rect)

        # 보기 박스
        pygame.draw.rect(window, WHITE, box1_rect, 3)
        pygame.draw.rect(window, WHITE, box2_rect, 3)

        # 보기 텍스트
        opt1_surf = quiz_font.render("1) " + options[0], True, WHITE)
        opt2_surf = quiz_font.render("2) " + options[1], True, WHITE)
        window.blit(opt1_surf, (box1_rect.right + 20, box1_rect.y))
        window.blit(opt2_surf, (box2_rect.right + 20, box2_rect.y))

        # 결과 메시지
        if result is True:
            msg = "정답입니다! (지능 +4)"
            msg_surf = small_font.render(msg, True, WHITE)
            msg_rect = msg_surf.get_rect(center=(full_w // 2, int(full_h * 0.8)))
            window.blit(msg_surf, msg_rect)
        elif result is False:
            msg = "오답입니다! (지능 +2)"
            msg_surf = small_font.render(msg, True, WHITE)
            msg_rect = msg_surf.get_rect(center=(full_w // 2, int(full_h * 0.8)))
            window.blit(msg_surf, msg_rect)

        # 하단 안내
        if result is None:
            tip = "마우스 클릭 또는 1/2 키로 정답 선택"
        else:
            tip = "아무 키나 누르거나 클릭하면 본게임으로 돌아갑니다"
        tip_surf = small_font.render(tip, True, WHITE)
        tip_rect = tip_surf.get_rect(center=(full_w // 2, int(full_h * 0.9)))
        window.blit(tip_surf, tip_rect)

        pygame.display.flip()
        clock.tick(FPS)

    # 본게임 윈도우 복원
    window = pygame.display.set_mode(prev_window_size, pygame.RESIZABLE)
    pygame.display.set_caption(prev_caption[0])

    reload_assets_for_size(GAME_W, GAME_H)
    update_button_positions(GAME_W, GAME_H)

    if result is True:
        return "success"
    elif result is False:
        return "fail"
    else:
        return None

# -------------------------
# 버튼/박스 설정 (메인 게임)
# -------------------------
BUTTON_TEXT = "START"
button_text_surf = FONT.render(BUTTON_TEXT, True, (255, 255, 255))
button_box = pygame.Rect(0, 0, 220, 72)

TUTORIAL_BUTTON_TEXT = "GO!"
tutorial_button_box = pygame.Rect(0, 0, 160, 60)
next_button_box = pygame.Rect(0, 0, 140, 55)

stats_button_rect = pygame.Rect(0, 0, 110, 45)
days_box_rect = pygame.Rect(0, 0, 150, 45)

mini_labels = ["체력", "지능", "외모", "포만"]
mini_buttons = []

sleep_button_rect = pygame.Rect(0, 0, 160, 60)

# -------------------------
# 게임 상태
# -------------------------
START_SCREEN = 0
TUTORIAL_SCREEN = 1
STORY_1 = 2
STORY_2 = 3
STORY_3 = 4
GAME_PLAY = 5
SLEEP_PROMPT = 6

game_state = START_SCREEN

# -------------------------
# 스토리 텍스트
# -------------------------
STORY_TEXTS = [
    "하아아아암 졸리다...\n(휴대폰을 확인하며)",
    "허거덩거덩스!!!!! \n컴사 기말 프로젝트가 \n5일 남았다고???",
    "너무 많이 남았네 \n밥 부터 먹어야지 야르!!!"
]

# -------------------------
# 본게임용 정보
# -------------------------
stats_panel_visible = False
days_left = 5
speech_text = "오늘 뭐 할까?"
actions_today = 0

player_stats = {
    "체력": 0,
    "지능": 0,
    "외모": 0,
    "포만": 0,
}

# -------------------------
# UI: 둥근 박스
# -------------------------
def draw_rounded_rect(surface, color, rect, radius):
    temp = pygame.Surface((rect.width, rect.height), pygame.SRCALPHA)
    pygame.draw.rect(temp, color, (0, 0, rect.width, rect.height), border_radius=radius)
    surface.blit(temp, rect.topleft)

# -------------------------
# 페이드 전환 (메인 게임용, screen 위에서)
# -------------------------
def fade_transition(draw_from_func, draw_to_func):
    # from_surf
    draw_from_func()
    from_surf = screen.copy()
    # to_surf
    draw_to_func()
    to_surf = screen.copy()

    start_ticks = pygame.time.get_ticks()
    duration_ms = 350
    while True:
        elapsed = pygame.time.get_ticks() - start_ticks
        if elapsed >= duration_ms:
            break
        alpha = min(255, int(255 * (elapsed / duration_ms)))
        screen.blit(from_surf, (0, 0))
        temp = to_surf.copy()
        temp.set_alpha(alpha)
        screen.blit(temp, (0, 0))

        blit_game_to_window()
        clock.tick(FPS)

# -------------------------
# 텍스트 줄바꿈 렌더링
# -------------------------
def draw_multiline_text(text, font, color, rect, line_gap=6):
    lines = text.split("\n")
    y = rect.top + 12
    for line in lines:
        surf = font.render(line, True, color)
        screen.blit(surf, (rect.left + 16, y))
        y += surf.get_height() + line_gap

# -------------------------
# 리사이즈 시 이미지/버튼 재계산 (논리 크기 기준)
# -------------------------
def reload_assets_for_size(w, h):
    global background_start, background_tutorial, background_game_default
    global background_morning, background_noon, background_evening
    global tutorial_img, story_photo_imgs, game_photo_img, sleeping_img
    global mini_icon_imgs

    background_start = load_and_scale(START_BG_FILE, (w, h))
    background_tutorial = load_and_scale(TUTORIAL_BG_FILE, (w, h))
    background_game_default = load_and_scale(GAME_BG_FILE, (w, h))

    background_morning = load_and_scale(MORNING_BG_FILE, (w, h))
    background_noon    = load_and_scale(NOON_BG_FILE, (w, h))
    background_evening = load_and_scale(EVENING_BG_FILE, (w, h))

    tutorial_img = load_and_scale(TUTORIAL_IMG_FILE, (int(w * 0.8), int(h * 0.6)))

    story_photo_imgs = []
    for path in STORY_PHOTO_FILES:
        img = load_keep_aspect(path, (int(w * 0.65), int(h * 0.35)))
        story_photo_imgs.append(img)

    game_photo_img = load_keep_aspect(GAME_PHOTO_FILE, (int(w * 0.65), int(h * 0.33)))
    sleeping_img = load_keep_aspect(SLEEP_PHOTO_FILE, (int(w * 0.65), int(h * 0.33)))

    mini_icon_imgs.clear()
    for path in MINI_ICON_FILES:
        img = load_keep_aspect(path, (MINI_BTN_BASE_SIZE, MINI_BTN_BASE_SIZE))
        mini_icon_imgs.append(img)

def update_button_positions(w, h):
    global mini_buttons

    button_box.center = (w // 2, h // 2 + 150)
    tutorial_button_box.topleft = (w - 160 - 20, h - 60 - 20)
    next_button_box.topleft = (w - 140 - 20, h - 55 - 20)

    stats_button_rect.topleft = (20, 20)
    days_box_rect.size = (150, 45)
    days_box_rect.topright = (w - 20, 20)

    mini_buttons = []
    gap = 5  # 간격 조금 줄여서 아이콘 더 크게
    max_size_by_width = (w - 3 * gap) // 4
    mini_btn_size = min(MINI_BTN_BASE_SIZE, max_size_by_width)

    total_w = mini_btn_size * 4 + gap * 3
    start_x = (w - total_w) // 2
    y = h - mini_btn_size - 30

    for label_idx, label in enumerate(mini_labels):
        rect = pygame.Rect(start_x + label_idx * (mini_btn_size + gap), y,
                           mini_btn_size, mini_btn_size)
        mini_buttons.append({"rect": rect, "label": label})

    sleep_button_rect.center = (w // 2, int(h * 0.82))

reload_assets_for_size(GAME_W, GAME_H)
update_button_positions(GAME_W, GAME_H)

# -------------------------
# 화면 비율 유지용: 윈도우 <-> 게임 좌표 변환
# -------------------------
def get_game_view_params():
    win_w, win_h = window.get_size()
    target_ratio = GAME_W / GAME_H
    win_ratio = win_w / win_h if win_h != 0 else target_ratio

    if win_ratio > target_ratio:
        surf_h = win_h
        surf_w = int(surf_h * target_ratio)
    else:
        surf_w = win_w
        surf_h = int(surf_w / target_ratio)

    scale = surf_w / GAME_W
    offset_x = (win_w - surf_w) // 2
    offset_y = (win_h - surf_h) // 2
    return scale, offset_x, offset_y, surf_w, surf_h

def window_to_game(pos):
    mx, my = pos
    scale, ox, oy, surf_w, surf_h = get_game_view_params()
    if not (ox <= mx < ox + surf_w and oy <= my < oy + surf_h):
        return None
    gx = (mx - ox) / scale
    gy = (my - oy) / scale
    return int(gx), int(gy)

def blit_game_to_window():
    scale, ox, oy, surf_w, surf_h = get_game_view_params()
    window.fill((0, 0, 0))
    if int(surf_w) != GAME_W or int(surf_h) != GAME_H:
        scaled = pygame.transform.smoothscale(screen, (surf_w, surf_h))
        window.blit(scaled, (ox, oy))
    else:
        window.blit(screen, (ox, oy))
    pygame.display.update()

# -------------------------
# 화면 그리기 - 시작/튜토리얼/스토리
# -------------------------
def draw_start_screen():
    screen.fill((25, 20, 60))
    screen.blit(background_start, (0, 0))

    hovered = button_box.collidepoint(window_to_game(pygame.mouse.get_pos()) or (-9999, -9999))
    alpha = 200 if hovered else 160
    draw_rounded_rect(screen, (0, 0, 0, alpha), button_box, 15)
    pygame.draw.rect(screen, (255, 255, 255), button_box, 2, border_radius=15)

    text = load_font(64).render(BUTTON_TEXT, True, (255, 255, 255)) if hovered else button_text_surf
    screen.blit(text, text.get_rect(center=button_box.center))

def draw_tutorial_screen():
    screen.fill((15, 50, 80))
    screen.blit(background_tutorial, (0, 0))

    box_w = int(GAME_W * 0.8)
    box_h = int(GAME_H * 0.6)
    tut_rect = pygame.Rect(0, 0, box_w, box_h)
    tut_rect.center = (GAME_W // 2, GAME_H // 2 - 40)

    draw_rounded_rect(screen, (240, 240, 240, 230), tut_rect, 25)
    pygame.draw.rect(screen, (80, 80, 80), tut_rect, 3, border_radius=25)

    img_rect = tutorial_img.get_rect(center=tut_rect.center)
    screen.blit(tutorial_img, img_rect)

    draw_rounded_rect(screen, (0, 0, 0, 160), tutorial_button_box, 15)
    pygame.draw.rect(screen, (255, 255, 255), tutorial_button_box, 2, border_radius=15)

    btn_text = TUTORIAL_FONT.render(TUTORIAL_BUTTON_TEXT, True, (255, 255, 255))
    screen.blit(btn_text, btn_text.get_rect(center=tutorial_button_box.center))

def draw_story_screen(page_idx):
    screen.fill((30, 30, 70))
    screen.blit(background_game_default, (0, 0))

    img = story_photo_imgs[page_idx]
    img_rect = img.get_rect(center=(GAME_W // 2, int(GAME_H * 0.38)))
    screen.blit(img, img_rect)

    bubble_w = int(GAME_W * 0.78)
    bubble_h = int(GAME_H * 0.20)
    bubble_rect = pygame.Rect(0, 0, bubble_w, bubble_h)
    bubble_rect.center = (GAME_W // 2, int(GAME_H * 0.72))

    draw_rounded_rect(screen, (180, 180, 180, 230), bubble_rect, 18)
    pygame.draw.rect(screen, (120, 120, 120), bubble_rect, 2, border_radius=18)

    draw_multiline_text(STORY_TEXTS[page_idx], STORY_FONT, (20, 20, 20), bubble_rect)

    draw_rounded_rect(screen, (0, 0, 0, 170), next_button_box, 12)
    pygame.draw.rect(screen, (255, 255, 255), next_button_box, 2, border_radius=12)
    nxt = NEXT_FONT.render("NEXT ▶", True, (255, 255, 255))
    screen.blit(nxt, nxt.get_rect(center=next_button_box.center))

    page_tag = NEXT_FONT.render(f"{page_idx+1}/3", True, (255, 255, 255))
    screen.blit(page_tag, (20, GAME_H - 45))

# -------------------------
# 스탯창 (텍스트형)
# -------------------------
def draw_stats_panel():
    overlay = pygame.Surface((GAME_W, GAME_H), pygame.SRCALPHA)
    overlay.fill((0, 0, 0, 150))
    screen.blit(overlay, (0, 0))

    panel_w = int(GAME_W * 0.75)
    panel_h = int(GAME_H * 0.45)
    panel_rect = pygame.Rect(0, 0, panel_w, panel_h)
    panel_rect.center = (GAME_W // 2, GAME_H // 2)

    draw_rounded_rect(screen, (240, 240, 240, 255), panel_rect, 20)
    pygame.draw.rect(screen, (80, 80, 80), panel_rect, 2, border_radius=20)

    title = STAT_FONT.render("에녹이 스탯", True, (20, 20, 20))
    screen.blit(title, (panel_rect.left + 20, panel_rect.top + 20))

    y = panel_rect.top + 80
    for name, value in player_stats.items():
        line = f"{name} - {value}"
        line_surf = STAT_FONT.render(line, True, (30, 30, 30))
        screen.blit(line_surf, (panel_rect.left + 40, y))
        y += line_surf.get_height() + 12

    hint = DAY_FONT.render("스탯 버튼을 다시 누르면 창이 닫혀요", True, (60, 60, 60))
    screen.blit(hint, (panel_rect.left + 20, panel_rect.bottom - 40))

# -------------------------
# 본게임 화면 그리기
# -------------------------
def draw_game_play():
    if actions_today == 0:
        bg = background_morning or background_game_default
    elif actions_today == 1:
        bg = background_noon or background_game_default
    else:
        bg = background_evening or background_game_default

    screen.fill((20, 45, 70))
    screen.blit(bg, (0, 0))

    hovered_stats = stats_button_rect.collidepoint(
        window_to_game(pygame.mouse.get_pos()) or (-9999, -9999)
    )
    alpha_stats = 190 if hovered_stats else 150
    draw_rounded_rect(screen, (0, 0, 0, alpha_stats), stats_button_rect, 10)
    pygame.draw.rect(screen, (255, 255, 255), stats_button_rect, 2, border_radius=10)
    stats_text = DAY_FONT.render("스탯", True, (255, 255, 255))
    screen.blit(stats_text, stats_text.get_rect(center=stats_button_rect.center))

    draw_rounded_rect(screen, (0, 0, 0, 150), days_box_rect, 10)
    pygame.draw.rect(screen, (255, 255, 255), days_box_rect, 2, border_radius=10)
    label = DAY_FONT.render("남은 날", True, (230, 230, 230))
    screen.blit(label, (days_box_rect.left + 10, days_box_rect.top + 6))
    value = DAY_FONT.render(f"D-{days_left}", True, (255, 255, 255))
    screen.blit(value, (days_box_rect.left + 10, days_box_rect.top + 24))

    img_rect = game_photo_img.get_rect(center=(GAME_W // 2, int(GAME_H * 0.32)))
    screen.blit(game_photo_img, img_rect)

    bubble_w = int(GAME_W * 0.80)
    bubble_h = int(GAME_H * 0.18)
    bubble_rect = pygame.Rect(0, 0, bubble_w, bubble_h)

    if mini_buttons:
        mini_top = mini_buttons[0]["rect"].top
        bubble_rect.bottom = mini_top - 10
    else:
        bubble_rect.center = (GAME_W // 2, int(GAME_H * 0.75))

    bubble_rect.centerx = GAME_W // 2

    draw_rounded_rect(screen, (180, 180, 180, 235), bubble_rect, 18)
    pygame.draw.rect(screen, (120, 120, 120), bubble_rect, 2, border_radius=18)
    draw_multiline_text(speech_text, STORY_FONT, (20, 20, 20), bubble_rect)

    # 미니게임 아이콘: 박스 없이 아이콘만 표시
    for idx, btn in enumerate(mini_buttons):
        rect = btn["rect"]
        if idx < len(mini_icon_imgs) and mini_icon_imgs[idx] is not None:
            icon = mini_icon_imgs[idx]
            icon_rect = icon.get_rect(center=rect.center)
            screen.blit(icon, icon_rect)
        else:
            label_surf = MINI_FONT.render(btn["label"], True, (255, 255, 255))
            screen.blit(label_surf, label_surf.get_rect(center=rect.center))

    if stats_panel_visible:
        draw_stats_panel()

# -------------------------
# 밤 화면 (취침하기)
# -------------------------
def draw_sleep_prompt():
    screen.fill((0, 0, 0))

    img_rect = game_photo_img.get_rect(center=(GAME_W // 2, int(GAME_H * 0.32)))
    screen.blit(game_photo_img, img_rect)

    bubble_w = int(GAME_W * 0.80)
    bubble_h = int(GAME_H * 0.18)
    bubble_rect = pygame.Rect(0, 0, bubble_w, bubble_h)
    bubble_rect.center = (GAME_W // 2, int(GAME_H * 0.62))

    draw_rounded_rect(screen, (180, 180, 180, 235), bubble_rect, 18)
    pygame.draw.rect(screen, (120, 120, 120), bubble_rect, 2, border_radius=18)

    text = "오늘 하루는 여기까지!\n취침하기를 눌러서 다음 날로 가자."
    draw_multiline_text(text, STORY_FONT, (20, 20, 20), bubble_rect)

    draw_rounded_rect(screen, (0, 0, 0, 190), sleep_button_rect, 12)
    pygame.draw.rect(screen, (255, 255, 255), sleep_button_rect, 2, border_radius=12)
    sleep_text = NEXT_FONT.render("취침하기", True, (255, 255, 255))
    screen.blit(sleep_text, sleep_text.get_rect(center=sleep_button_rect.center))

# -------------------------
# 자는 화면 → 다음 날
# -------------------------
def show_sleeping_and_next_day():
    global days_left, actions_today, speech_text, game_state

    screen.fill((0, 0, 0))
    img_rect = sleeping_img.get_rect(center=(GAME_W // 2, GAME_H // 2))
    screen.blit(sleeping_img, img_rect)
    blit_game_to_window()

    pygame.time.delay(1000)

    if days_left > 1:
        days_left -= 1
    else:
        days_left = 1

    actions_today = 0
    speech_text = "새로운 하루가 시작됐다!\n오늘은 뭐 할까?"
    game_state = GAME_PLAY

# -------------------------
# 메인 루프
# -------------------------
running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            break

        if event.type == pygame.VIDEORESIZE:
            window = pygame.display.set_mode((event.w, event.h), pygame.RESIZABLE)

        # Hover: 특정 미니게임 위에 올리면 대사 변경 (배경은 그대로)
        if event.type == pygame.MOUSEMOTION and game_state == GAME_PLAY:
            pos = window_to_game(event.pos)
            if pos is not None:
                mx, my = pos
                for idx, btn in enumerate(mini_buttons):
                    if idx == 1 and btn["rect"].collidepoint(mx, my) and actions_today < 3:
                        speech_text = "컴퓨팅 사고 퀴즈를 풀어\n지능을 올려볼까?"
                        break
                    if idx == 2 and btn["rect"].collidepoint(mx, my) and actions_today < 3:
                        speech_text = "카드 짝맞추기 게임으로\n외모를 업그레이드 해볼까?"
                        break

        # 키 입력
        if event.type == pygame.KEYDOWN:
            if game_state == START_SCREEN and event.key in (pygame.K_RETURN, pygame.K_SPACE):
                fade_transition(draw_start_screen, draw_tutorial_screen)
                game_state = TUTORIAL_SCREEN

            elif game_state == TUTORIAL_SCREEN and event.key in (pygame.K_RETURN, pygame.K_SPACE):
                fade_transition(draw_tutorial_screen, lambda: draw_story_screen(0))
                game_state = STORY_1

            elif game_state in (STORY_1, STORY_2, STORY_3) and event.key in (pygame.K_RETURN, pygame.K_SPACE):
                next_state = game_state + 1
                if next_state == GAME_PLAY:
                    fade_transition(lambda: draw_story_screen(game_state - STORY_1),
                                    draw_game_play)
                else:
                    fade_transition(lambda: draw_story_screen(game_state - STORY_1),
                                    lambda: draw_story_screen(next_state - STORY_1))
                game_state = next_state

        # 마우스 클릭
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            game_pos = window_to_game(event.pos)
            if game_pos is None:
                continue
            mx, my = game_pos

            if game_state == START_SCREEN and button_box.collidepoint(mx, my):
                fade_transition(draw_start_screen, draw_tutorial_screen)
                game_state = TUTORIAL_SCREEN

            elif game_state == TUTORIAL_SCREEN and tutorial_button_box.collidepoint(mx, my):
                fade_transition(draw_tutorial_screen, lambda: draw_story_screen(0))
                game_state = STORY_1

            elif game_state in (STORY_1, STORY_2, STORY_3):
                next_state = game_state + 1
                if next_state == GAME_PLAY:
                    fade_transition(lambda: draw_story_screen(game_state - STORY_1),
                                    draw_game_play)
                else:
                    fade_transition(lambda: draw_story_screen(game_state - STORY_1),
                                    lambda: draw_story_screen(next_state - STORY_1))
                game_state = next_state

            elif game_state == GAME_PLAY:
                if stats_button_rect.collidepoint(mx, my):
                    stats_panel_visible = not stats_panel_visible

                for idx, btn in enumerate(mini_buttons):
                    rect = btn["rect"]
                    if rect.collidepoint(mx, my):

                        if actions_today >= 3:
                            break

                        if idx == 0:  # 체력
                            speech_text = "에녹이는 운동을 해서 땀을 쭉 뺐다.\n체력이 조금 올랐다!"
                            player_stats["체력"] = min(100, player_stats["체력"] + 10)
                            actions_today += 1

                        elif idx == 1:  # 지능 퀴즈 미니게임
                            result = play_intelligence_quiz_minigame()
                            if result == "success":
                                speech_text = "퀴즈 정답!\n지능이 4만큼 올랐다!"
                                player_stats["지능"] = min(100, player_stats["지능"] + 4)
                                actions_today += 1
                            elif result == "fail":
                                speech_text = "퀴즈 오답...\n그래도 지능이 2만큼 올랐다!"
                                player_stats["지능"] = min(100, player_stats["지능"] + 2)
                                actions_today += 1
                            else:
                                speech_text = "지능 미니게임을 중단했다."

                        elif idx == 2:  # 외모 미니게임
                            result = play_appearance_minigame()
                            if result == "success":
                                speech_text = "카드 짝맞추기 성공!\n외모가 4만큼 올랐다!"
                                player_stats["외모"] = min(100, player_stats["외모"] + 4)
                                actions_today += 1
                            elif result == "fail":
                                speech_text = "카드 짝맞추기 실패...\n그래도 외모가 2만큼 올랐다!"
                                player_stats["외모"] = min(100, player_stats["외모"] + 2)
                                actions_today += 1
                            else:
                                speech_text = "외모 미니게임을 중단했다."

                        elif idx == 3:  # 포만
                            speech_text = "에녹이는 맛있는 밥을 먹었다.\n포만감이 조금 올랐다!"
                            player_stats["포만"] = min(100, player_stats["포만"] + 10)
                            actions_today += 1

                        if actions_today >= 3:
                            stats_panel_visible = False
                            fade_transition(draw_game_play, draw_sleep_prompt)
                            game_state = SLEEP_PROMPT

                        break

            elif game_state == SLEEP_PROMPT:
                if sleep_button_rect.collidepoint(mx, my):
                    show_sleeping_and_next_day()

    # 화면 그리기
    if game_state == START_SCREEN:
        draw_start_screen()
    elif game_state == TUTORIAL_SCREEN:
        draw_tutorial_screen()
    elif game_state == STORY_1:
        draw_story_screen(0)
    elif game_state == STORY_2:
        draw_story_screen(1)
    elif game_state == STORY_3:
        draw_story_screen(2)
    elif game_state == GAME_PLAY:
        draw_game_play()
    elif game_state == SLEEP_PROMPT:
        draw_sleep_prompt()

    blit_game_to_window()
    clock.tick(FPS)

pygame.quit()
sys.exit()
